%option prefix="newdb"
%option malloc="mem_alloc"
%option free="mem_free"

%header-preamble {
#include "vh/config.h"
#include "vh/str.h"
#include <stdint.h>

C_BEGIN
}

%source-includes{
#include "vh/db.h"
#include "vh/log.h"
#include "vh/mem.h"
#include "vh/mfile.h"
#include "sqlite/sqlite3.h"
#include <ctype.h>
}

%header-postamble {
VH_PUBLIC_API struct newdb_interface*
newdb(const char* type);

VH_PRIVATE_API int
newdb_init(void);

VH_PRIVATE_API void
newdb_deinit(void);

C_END
}

%function migrate(int reinit_db) {
    return check_version_and_migrate(ctx->db, reinit_db);
}
%query motion,add(uint64_t hash40, struct str_view string) {
    type insert-or-ignore
    table motions
}
%query motion,exists(uint64_t hash40) {
    type exists
    table motions
}
%query motion_label,add_or_get_group(struct str_view name) {
    type insert-or-get
    table motion_groups
    return id
}
%query motion_label,add_or_get_layer(int group_id, struct str_view name) {
    type insert-or-get
    stmt {
        WITH priorities AS (
            WITH list(id) AS (VALUES(0))
            SELECT IFNULL(priority, 0) + 1 priority FROM test
            FULL OUTER JOIN list USING(id)
            ORDER BY priority DESC LIMIT 1)
        INSERT INTO motion_layers (group_id, priority, name)
        VALUES (?, (SELECT priority FROM priorities), ?)
        ON CONFLICT DO UPDATE SET group_id=excluded.group_id
        RETURNING id;
    }
    return id
}
%query motion_label,add_or_get_category(struct str_view name) {
    type insert-or-get
    table motion_categories
    return id
}
%query motion_label,add_or_get_usage(struct str_view name) {
    type insert-or-get
    table motion_usages
    return id
}
%query motion_label,add_or_get_label(
        uint64_t hash40,
        int fighter_id,
        int layer_id,
        int category_id,
        int usage_id,
        struct str_view label) {
    type insert-or-get
    table motion_labels
    return id
}
%query motion_label,to_motions(struct db* ctx, int fighter_id, struct str_view label, struct vec* motions_out) {
    type select-multi
    table motion_labels
    return hash40
}
%query motion_label,to_notation_label(int fighter_id, uint64_t motion, struct str* label) {
    type select-single
    stmt {
        SELECT label FROM motion_labels
        JOIN motion_layers ON motion_layers.id=motion_labels.layer_id
        WHERE hash40=? AND fighter_id=? AND usage_id=? AND label <> ''
        ORDER BY priority ASC
        LIMIT 1;
    }
    return label
}
%query fighter,add(int id, struct str_view name) {
    type insert-or-ignore
    table fighters
}
%query fighter,get_name(int id, struct str* name) {
    type select-single
    table fighters
    return name
}
%query stage,add(int id, struct str_view name) {
    type insert-or-ignore
    table stages
}
%query status_enum,add(int fighter_id null, int value, struct str_view name) {
    type insert-or-ignore
    table status_enums
}
%query hit_status_enum,add(int id, struct str_view name) {
    type insert-or-ignore
    table hit_status_enums
}
%query tournament,add_or_get(struct str_view name, struct str_view website) {
    type insert-or-get
    table tournaments
    return id
}
%query tournament,add_sponsor(int tournament_id, int sponsor_id) {
    type insert-or-ignore
    table tournament_sponsors
}
%query tournament,add_organizer(int tournament_id, int person_id) {
    type insert-or-ignore
    table tournament_organizers
}
%query tournament,add_commentator(int tournament_id, int person_id) {
    type insert-or-ignore
    table tournament_commentators
}
%query event,add_or_get_type(struct str_view name) {
    type insert-or-get
    table event_types
    return id
}
%query event,add_or_get(int event_type_id, struct str_view url) {
    type insert-or-get
    table event_types
    return id
}
%query round,add_or_get_type(struct str_view short_name, struct str_view long_name) {
    type insert-or-get
    table round_types
    return id
}
%query set_format,add_or_get(struct str_view short_name, struct str_view long_name) {
    type insert-or-get
    table set_formats
    return id
}
%query team,add_or_get(struct str_view short_name, struct str_view url) {
    type insert-or-get
    table teams
    return id
}
%query team,add_member(int team_id, int person_id) {
    type insert-or-ignore
    table teams
}
%query sponsor,add_or_get(
        int sponsor_id,
        struct str_view name,
        struct str_view tag,
        struct str_view social,
        struct str_view pronouns) {
    type insert-or-get
    table sponsors
    return id
}
%query person,add_or_get(struct str_view short_name, struct str_view full_name, struct str_view website) {
    type insert-or-get
    table people
    return id, sponsor_id, name, tag, social, pronouns
}
%query person,get_id_from_name(struct str_view name) {
    type select-single
    table people
    return id
}
%query person,get_team_id_from_name(struct str_view name) {
    type select-single
    stmt {
        SELECT team_id
        FROM team_members
        JOIN people ON team_members.person_id=people.id
        WHERE name=?;
    }
    return team_id
}
%query person,set_tag(int id, struct str_view tag) {
    type update-or-ignore tag
    table people
}
%query person,set_social(int id, struct str_view social) {
    type update-or-ignore social
    table people
}
%query person,set_pronouns(int id, struct str_view pronouns) {
    type update-or-ignore pronouns
    table people
}

%source-preamble {
static int
exec_sql_wrapper(sqlite3* db, const char* sql)
{
    char* error_message;
    int ret = sqlite3_exec(db, sql, NULL, NULL, &error_message);
    if (ret != SQLITE_OK)
    {
        log_sqlite_err(ret, error_message, sqlite3_errmsg(db));
        sqlite3_free(error_message);
        return -1;
    }
    return 0;
}

static int
run_migration_script(sqlite3* db, const char* file_name)
{
    int ret;
    struct mfile mf;
    sqlite3_stmt* stmt;
    const char* sql;
    const char* sql_next;
    int sql_len;

    if (mfile_map(&mf, file_name) != 0)
        goto open_script_failed;

    sql = mf.address;
    sql_len = mf.size;

    log_info("Running migration script '%s'\n", file_name);

next_step:
    ret = sqlite3_prepare_v2(db, sql, sql_len, &stmt, &sql_next);
    if (ret != SQLITE_OK)
    {
        log_sqlite_err(ret, sqlite3_errstr(ret), sqlite3_errmsg(db));
        goto prepare_failed;
    }
retry_step:
    switch (ret = sqlite3_step(stmt))
    {
        case SQLITE_BUSY:
            goto retry_step;
        case SQLITE_ROW:
        case SQLITE_DONE:
            sql_len -= (int)(sql_next - sql);
            sql = sql_next;
            for (; sql_len && isspace(*sql); ++sql, --sql_len) {}
            if (sql_len <= 0)
                break;
            sqlite3_finalize(stmt);
            goto next_step;
        default:
            log_sqlite_err(ret, sqlite3_errstr(ret), sqlite3_errmsg(db));
            goto exec_failed;
    }

    sqlite3_finalize(stmt);
    mfile_unmap(&mf);
    return 0;

    exec_failed        : sqlite3_finalize(stmt);
    prepare_failed     : mfile_unmap(&mf);
    open_script_failed : return -1;
}

static int
check_version_and_migrate(sqlite3* db, int reinit_db)
{
    int ret;
    int version;
    sqlite3_stmt* stmt;

    ret = sqlite3_prepare_v2(db, "PRAGMA user_version", -1, &stmt, NULL);
    if (ret != SQLITE_OK)
    {
        log_sqlite_err(ret, sqlite3_errstr(ret), sqlite3_errmsg(db));
        return -1;
    }

    ret = sqlite3_step(stmt);
    if (ret != SQLITE_ROW)
    {
        log_sqlite_err(ret, sqlite3_errstr(ret), sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return -1;
    }

    version = sqlite3_column_int(stmt, 0);
    sqlite3_finalize(stmt);
    log_dbg("db version: %d\n", version);

    if (exec_sql_wrapper(db, "BEGIN TRANSACTION") != 0)
        return -1;

    if (reinit_db)
    {
        log_note("Downgrading db to version 0\n");
        switch (version)
        {
            case 1: if (run_migration_script(db, "migrations/1-schema.down.sql") != 0) goto migrate_failed;
            case 0: break;
        }
        version = 0;
    }

    switch (version)
    {
        case 0: if (run_migration_script(db, "migrations/1-schema.up.sql") != 0) goto migrate_failed;
        /*case 1: if (upgrade_to_v2(db) != 0) goto migrate_failed;
        case 2: if (upgrade_to_v3(db) != 0) goto migrate_failed;*/
        case 1: break;

        default:
            log_err("Unknown database version %d. Aborting all operations\n", version);
            goto migrate_failed;
    }

    if (exec_sql_wrapper(db, "PRAGMA user_version=1") != 0)
        goto migrate_failed;

    if (exec_sql_wrapper(db, "COMMIT TRANSACTION") != 0)
        goto migrate_failed;

    log_note("Successfully migrated from version %d to version 1\n", version);

    return 0;

    migrate_failed : exec_sql_wrapper(db, "ROLLBACK TRANSACTION");
    return -1;
}
}

%source-postamble {
struct newdb_interface* newdb(const char* type)
{
    if (strcmp("sqlite", type) == 0)
        return &db_sqlite;
    return NULL;
}

#if defined(VH_MEM_DEBUGGING)
static int
vh_mem_roundup(int size) { return size; }
static int
vh_mem_init(void* user) { (void)user; return 0; }
static void
vh_mem_deinit(void* user) { (void)user; }

static struct sqlite3_mem_methods vh_mem_sqlite = {
    mem_alloc,
    mem_free,
    mem_realloc,
    mem_allocated_size,
    vh_mem_roundup,
    vh_mem_init,
    vh_mem_deinit,
    NULL
};
#endif

int
newdb_init(void)
{
#if defined(VH_MEM_DEBUGGING)
    sqlite3_config(SQLITE_CONFIG_MALLOC, &vh_mem_sqlite);
#endif

    if (sqlite3_initialize() != SQLITE_OK)
        return -1;
    return 0;
}

void
newdb_deinit(void)
{
    sqlite3_shutdown();
}
}
